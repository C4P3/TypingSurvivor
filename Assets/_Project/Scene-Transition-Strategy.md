# **シーン遷移とゲームフロー戦略**

## **1. 設計思想**

本ドキュメントは、アプリケーションの起動からゲームプレイ、再戦、そして終了に至るまでのユーザー体験を司るシーン遷移とゲームフローの戦略を定義します。設計は、既存のアーキテクチャ原則（疎結合、サーバー権威）を遵守し、以下の目標を達成することを目的とします。

*   **シームレスなユーザー体験**: シーンの再読み込みを最小限に抑え、待機時間や画面の切り替えによるストレスを軽減する。
*   **高い保守性と拡張性**: 全てのゲームモード（シングル、マルチ、特殊ルール）で単一のゲームシーンを共有し、コードとアセットの重複を排除する。
*   **動的なレイアウト**: プレイヤー数やゲームモードに応じて、画面分割などのカメラレイアウトを柔軟に変更できる構造を実現する。

## **2. シーン構成**

本プロジェクトは、以下の3つの主要シーンで構成されます。

| シーン名 | 役割 |
| :--- | :--- |
| **`App.unity`** | **起動・初期化シーン**。ゲーム起動時の唯一のエントリーポイント。`AppManager`や`NetworkManager`など、永続化が必要なコアシステムを初期化し、即座に`MainMenu`シーンへ遷移する。 |
| **`MainMenu.unity`** | **ハブシーン**。UGSへのサインイン、ゲームモードの選択、マッチング待機など、ゲームプレイ前の全ての機能を提供する。 |
| **`Game.unity`** | **プレイシーン**。全てのゲームモード（シングル、2人対戦、4人対戦など）におけるゲームプレイが実行される唯一のシーン。 |

## **3. ゲームフロー詳細**

### **3.1. ゲームルールの選択と保持**

1.  **選択 (`MainMenu`シーン)**: プレイヤーがUI（ボタンなど）からプレイしたいモードを選択します。
2.  **保持 (`AppManager`)**: `MainMenuManager`は、選択されたモードを示す文字列（例: `"RankedMatch_2P"`, `"SinglePlayer"`) を、永続オブジェクトである`AppManager`の静的プロパティ `AppManager.GameMode` に格納します。
3.  **遷移**: `MainMenuManager`が`NetworkManager`を通じて`Game.unity`へのシーン遷移を開始します。
4.  **注入 (`Game`シーン)**: `Game`シーンの`GameSceneBootstrapper`が`AppManager.GameMode`を読み取り、そのモードに応じた`IGameModeStrategy`や各種設定を`GameManager`に注入します。

### **3.2. マッチング待機フロー**

*   **場所**: マッチング待機は**`MainMenu`シーン内**で完結します。
*   **プロセス**:
    1.  「対戦を探す」ボタンを押すと、`MainMenuManager`がUGS Matchmakerなどのマッチングサービスへの接続を開始します。
    2.  UIは「検索中...」といったモーダル表示に切り替わります。プレイヤーはいつでもキャンセルできます。
    3.  マッチングが成功すると、`MainMenuManager`が通知を受け取り、`Game`シーンへの遷移処理を開始します。

### **3.3. 再戦処理フロー（シーン再読込なし）**

高速な再戦サイクルを実現するため、シーンの再読み込みは行いません。全体のフローは、各クラスが責務を分担するイベント駆動モデルで進行します。

1.  **ゲーム終了**: `GameManager`が`GamePhase`を`Finished`に変更します。
2.  **リザルト表示**: `GameUIManager`が`GamePhase`の変更を検知し、`Game`シーン上にリザルト画面のUIプレハブをインスタンス化して表示します。
3.  **再戦要求**:
    *   プレイヤーが「再戦」ボタンを押すと、`GameUIManager`経由でサーバーに`RequestRematch_ServerRpc`を送信します。
    *   サーバー側の`GameManager`は、どのプレイヤーが再戦を要求したかを記録し、全プレイヤーから要求が届くのを待ち受けます。
4.  **サーバー主導のゲーム状態リセット**:
    *   全員が合意した場合、サーバー側の`GameManager`が**指揮官**となり、以下のリセット処理を順次実行します。
        *   **マップ再生成**: `ILevelService.RegenerateMap()`を呼び出し、`LevelManager`にマップの完全な再生成を命令します。
        *   **ゲーム状態リセット**: 自身の管理する`GameState`（スコア、タイマーなど）を初期値に戻します。
        *   **プレイヤーリスポーン**:
            *   `ILevelService.GetSpawnPoints()`を呼び出し、新しいマップ用のスポーン地点を取得します。
            *   自身が管理する全`PlayerFacade`インスタンスに対し、新しいスポーン地点を引数にして`RespawnAt(position)`メソッドを呼び出します。
5.  **再戦開始**:
    *   `GameManager`は、リセット処理が完了した後、自身のゲームループを`Countdown`フェーズに進めます。
    *   クライアントは`GamePhase`の変更を検知し、`GameUIManager`がリザルトUIを破棄してカウントダウンUIを表示します。

### **3.4. メインメニューへの復帰**

リザルト画面で「メインメニューへ」を選択した場合、または接続が切断された場合は、`NetworkManager.Singleton.Shutdown()`を呼び出してセッションを安全に終了した後、`MainMenu.unity`シーンをロードします。

## **4. 動的な画面分割の実装**

対戦相手の画面を視認できるというゲームの面白さを実現するため、単一の`Game`シーン内でカメラレイアウトを動的に変更します。

1.  **`CameraManager`の導入**:
    *   `Game`シーンに、カメラのレイアウトと追従を専門に管理する`CameraManager`を配置します。
2.  **レイアウト決定**:
    *   `CameraManager`は、`GameSceneBootstrapper`から現在のゲームモードとプレイヤーリストを受け取ります。
3.  **Viewportの動的変更**:
    *   `CameraManager`は、プレイヤー数に応じて、シーンにプールされているカメラの**`Viewport Rect`**プロパティをスクリプトから変更します。
        *   **1人**: 1台のカメラを有効化し、全画面 `(Rect(0,0,1,1))` に設定。
        *   **2人**: 2台のカメラを有効化し、左右分割 `(Rect(0,0,0.5,1))` と `(Rect(0.5,0,0.5,1))` に設定。
        *   **4人**: 4台のカメラを有効化し、田の字分割に設定。
4.  **UIの追従**:
    *   各プレイヤーのHUD Canvasは、描画モードを`Screen Space - Camera`に設定します。
    *   `CameraManager`は、各プレイヤーのCanvasに、そのプレイヤーを映す専用カメラを割り当てます。これにより、画面が分割されてもUIは各プレイヤーの領域内に正しく描画されます。

この戦略により、ユーザー体験と開発効率を両立した、堅牢で拡張性の高いゲームフローを実現します。
