# **Gameplay機能 設計ドキュメント**

## **1\. 責務**

Gameplay機能は、ゲームの**ルール**そのものを司ります。具体的には以下の責務を持ちます。

* ゲーム全体の進行状態（待機中、カウントダウン、プレイ中、終了後など）の管理。  
* 酸素レベルやスコア、経過時間といった、ゲームの勝敗に関わるグローバルな状態の管理と同期。  
* ゲームルールの具体的な実装（シングルプレイとマルチプレイでの勝利条件の違いなど）をカプセル化する。  
* 他のシステムから発行されたサーバーサイドイベントを購読し、ルールに基づいてGameStateを更新すること。

## **2\. ゲーム進行のステートマシン**

ゲーム全体の流れは、サーバーが一元管理するステートマシンによって制御されます。

### **2.1. ゲームフェーズ (GamePhase)**

ゲームの進行状態を表すEnumを定義します。
```csharp
public enum GamePhase  
{  
    WaitingForPlayers, // プレイヤーの接続待ち（マルチプレイ用）  
    Countdown,         // ゲーム開始前のカウントダウン  
    Playing,           // ゲームプレイ中  
    Finished,          // ゲーム終了（リザルト表示へ）  
}
```

### **2.2. GameManagerによる状態同期**

GameManagerは、現在のゲームフェーズをNetworkVariable\<GamePhase\>として保持します。サーバーがこの値を変更すると、その変更は自動的に全クライアントに同期されます。クライアントは、このフェーズの変更をOnValueChangedイベントで検知し、UIの表示切り替えやプレイヤーの入力制御などを行います。

## **3\. ゲームルールのカプセル化 (ストラテジーパターン)**

シングルプレイとマルチプレイで異なるゲームルール（特に終了条件）を柔軟に扱うため、ストラテジーパターンを採用します。

### **3.1. IGameModeStrategy.cs (Interface)**

ゲームの「ルールブック」の役割を担うインターフェースです。

* **bool IsGameOver(IGameStateReader gameState)**: 現在のゲーム状態で、ゲームが終了条件を満たしているかを判定します。  
* **GameResult CalculateResult(IGameStateReader gameState)**: ゲーム終了時に、勝者や最終スコアなどのリザルト情報を計算します。

### **3.2. 具体的なStrategyクラス**

* **SinglePlayerStrategy.cs**: プレイヤー自身の酸素が0になった場合にゲームオーバーと判定します。  
* **MultiPlayerStrategy.cs**: いずれかのプレイヤーがゲームオーバー状態になった場合に、ゲーム全体を終了と判定します。

GameManagerは、ゲーム起動モード（シングル/マルチ）に応じて、適切なStrategyインスタンスをDIなどで受け取り、ルールの判定をそのStrategyに完全に委譲します。これにより、GameManager自身は具体的なルールを知る必要がなくなります。

### **3.3. ランクマッチ戦略 (`RankedMatchStrategy`)**

ランクマッチのルールは、`RankedMatchStrategy`クラスにカプセル化されます。

*   **責務:**
    *   `IsGameOver()`: `MultiPlayerStrategy`と同様に、生存プレイヤー数に基づいてゲームの終了を判定します。
    *   `CalculateResult()`: ゲームの最終状態のみを考慮し、勝者と敗者を決定する**同期処理**に専念します。レート計算のような非同期処理は行いません。

*   **選択フロー:**
    *   `GameSceneBootstrapper`は、`AppManager.GameMode`が`RankedMatch`である場合、この`RankedMatchStrategy`を`GameManager`に注入します。

### (新規追加) 3.4. スコア送信サービス (`LeaderboardService`)

スコアの送信と管理は、ゲームプレイのルールから完全に分離された、専門の`LeaderboardService`が担当します。

*   **役割:** サーバーサイドで動作する、Unity Leaderboardへのスコア送信サービス。
*   **処理フロー:**
    1.  `GameManager`が発行する**ゲーム終了イベント** (`OnGameFinished(GameResult result)`) を購読します。
    2.  イベントを受け取ると、`GameResult`から各プレイヤーの最終スコアを特定します。
    3.  **非同期で**`LeaderboardService.SubmitScoreAsync()`を呼び出し、スコアをUnity Leaderboardに送信します。

この設計により、ゲームルール（同期処理）と、外部サービスとの通信（非同期処理）を明確に分離し、それぞれを独立してテスト・保守することが可能になります。

## **4\. サーバーのメインゲームループ**

GameManagerは、サーバー上でコルーチンとしてメインゲームループを実行します。このループは、**「一度きりのセットアップフェーズ」**と、再戦を可能にする**「繰り返し可能なゲームラウンドループ」**に明確に分離されています。

### **4.1. セットアップフェーズ (一度きり)**

サーバーが起動し、必要な数のプレイヤーが接続すると、以下の処理が一度だけ実行されます。

1.  **WaitingForPlayersフェーズ**: 必要な数のプレイヤーが接続するまで待機します。
2.  **InitialSpawnPhase**: 全プレイヤーの`GameObject`を`Instantiate`し、サーバー内部のプレイヤーリストに登録します。このインスタンス生成は、サーバーの生存期間中にこの一度しか行われません。

### **4.2. ゲームラウンドループ (繰り返し)**

セットアップが完了すると、以下のフェーズを繰り返すループに入ります。

1.  **Countdownフェーズ**: ゲーム開始前に数秒間のカウントダウンを行います。この間、プレイヤーの操作は無効化されます。
2.  **Playingフェーズ**:
    *   このフェーズの間、GameManagerは時間経過による各プレイヤーの酸素減少などの定常的な状態更新を行います。
    *   毎フレーム、`IGameModeStrategy.IsGameOver()`を呼び出し、終了条件をチェックします。
    *   他のシステムからのサーバーサイドイベントを購読し、スコア加算などの状態変更を非同期に実行します。
3.  **Finishedフェーズ**:
    *   `IsGameOver()`が`true`を返すと、このフェーズに移行します。
    *   `IGameModeStrategy.CalculateResult()`を呼び出し、リザルト情報を確定させます。
    *   **再戦待機**: 全プレイヤーから再戦要求(`RequestRematchServerRpc`)が届くのを待ち受けます。
    *   **次ラウンド準備**: 全員が合意すると、`GameManager`は次のラウンドの準備を行います。
        *   `LevelManager`にマップの再生成を指示します。
        *   `PlayerStatusSystem`に、セッション内限定のステータス効果をクリアさせます。
        *   `GameState`（スコア、酸素など）をリセットします。
        *   **既存の**プレイヤー`GameObject`を、新しいスポーン地点に再配置（リスポーン）させます。
    *   全ての準備が完了すると、ループの先頭（`Countdown`フェーズ）に戻り、シームレスに次のラウンドが開始されます。

### **全体のドキュメント:**　
[./README.md](../../../README.md)
### **関連ドキュメント:**
* [../Player/Player-Design.md](../Player/Player-Design.md)  
* [../UI/UI-Design.md](../UI/UI-Design.md)