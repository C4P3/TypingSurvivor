# **Typing機能 設計ドMキュメント**

## **1\. 責務**

Typing機能は、このゲームのコアメカニクスであるタイピングに関する全てのロジックを担います。

* ひらがな（または他の言語）から、タイピング用のローマ字（または他の入力文字列）への変換。  
* プレイヤーのキー入力を受け付け、正誤判定を行う。  
* タイピングの開始、成功、失敗といったイベントを外部（Player機能）に通知する。  
* キーコンフィグや多言語対応を見据えた、柔軟な入力処理。

**設計目標:**

* **データ駆動**: ローマ字への変換ルールや、タイピングの問題文を外部データ（JSON, CSV, ScriptableObject）として管理し、ロジックとデータを分離する。  
* **Input System連携**: Unityの新しいInput Systemと協調し、アクションベースの入力と文字入力を共存させる。

## **2\. 主要コンポーネントとデータ構造**

Typing機能は、責務の分離原則に基づき、以下のコンポーネント群で構成されます。

### **2.1. データ層**

*   **`TypingConversionTableSO` (ScriptableObject)**
    *   **役割**: `convertTable.json` を読み込み、ひらがなとローマ字の対応ルールを保持するデータアセットです。
    *   **目的**: ローマ字変換のルールをデータとして管理し、ロジックから完全に分離します。

### **2.2. サービス層**

*   **`ITypingService` / `TypingManager.cs`**
    *   **役割**: タイピング機能の窓口となるサービスです。`AppManager` によってライフサイクルが管理されます。
    *   **責務**:
        *   タイピングの開始 (`StartTyping`)、キャンセル、終了といったライフサイクルを管理します。
        *   UnityのInput Systemから文字入力イベント (`Keyboard.current.onTextInput`) を購読します。
        *   入力された文字を現在の `TypingChallenge` に渡し、正誤判定を依頼します。
        *   タイピングの成功、失敗、進捗といった結果をC#イベントで外部に通知します。

### **2.3. お題管理層**

*   **`TypingChallenge.cs`**
    *   **役割**: 一回のタイピングのお題に関する「状態」を管理するデータコンテナです。
    *   **責務**:
        *   原文、ひらがな、そして正解パターンを格納した **Trie（トライ木）** を保持します。
        *   `ProcessInput` メソッドを通じて一文字ずつの入力を受け付け、Trie木上の現在位置を更新し、正誤判定 (`TypeResult`) を返します。
        *   入力済み、および未入力のローマ字文字列を提供する責務を持ちます。
    *   **特徴**: Trie木の **構築ロジック自体は持ちません**。構築は `TrieBuilder` に完全に委譲します。

### **2.4. Trie構築層 (`Builder` フォルダ)**

`TypingChallenge` を生成するための、複雑なTrie木構築ロジックを担当する内部クラス群です。

*   **`KanaParser.cs`**
    *   **役割**: ひらがな文字列を解析し、後続の処理がしやすいように「かなトークン」のリストに変換します。
    *   **責務**: 文字列をスキャンし、通常のかな・拗音・促音(`っ`)・撥音(`ん`)を区別して `KanaToken` のリストを生成します。

*   **`TrieBuilder.cs`**
    *   **役割**: `KanaParser` が生成したトークンリストと変換テーブルを基に、Trie木を構築するメインロジックです。
    *   **責務**: 促音や撥音のような、前後のトークンによって変換パターンが変わる複雑なルールを解決し、全てのありうるローマ字パターンの組み合わせをTrie木として構築します。

## **3. 新Input Systemとの連携**

Player機能の設計更新に伴い、タイピングと通常操作でアクションマップを切り替える方式は廃止され、単一の`Gameplay`アクションマップに統一されました。これにより、よりシームレスな操作体験と実装の簡素化を目指します。

*   **統一されたアクションマップ**:
    *   `Move`や`CancelTyping`（Enterキー）など、ゲーム中に発生しうる全ての入力アクションが、単一の`Gameplay`アクションマップで定義されます。
*   **サーバーサイドでの入力解釈**:
    *   クライアントはプレイヤーの状態に関わらず、常に入力アクションを発行します。
    *   サーバー側（主に`PlayerFacade`）が、プレイヤーの現在の状態（`Roaming`, `Moving`, `Typing`など）を基に、その入力が持つ「意図」を判断し、適切な処理を実行します。
    *   例えば、`Typing`状態の時に`Move`入力が送られてきた場合、サーバーはこれを「タイピングを中断して移動する」という意図として解釈します。
*   **文字入力のハンドリング**:
    *   タイピングの文字入力自体は、アクションマップとは独立しています。
    *   `TypingManager`は、引き続き`Keyboard.current.onTextInput`イベントを直接購読することで文字入力を受け取ります。この仕組みはアクションマップの統一による影響を受けません。

### **全体のドキュメント:**　
[../../../README.md](../../../README.md)
### **関連ドキュメント:**
* [../Player/Player-Design.md](../Player/Player-Design.md)