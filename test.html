<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Result Screen Demo (Canvas)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');

        :root {
            --bg-color: #1a1a2e;
            --highlight-color: #00f7ff;
        }

        body {
            background-color: var(--bg-color);
            color: #e0e0e0;
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            flex-direction: column;
        }

        canvas {
            background: rgba(16, 16, 34, 0.8);
            border: 2px solid var(--highlight-color);
            box-shadow: 0 0 20px rgba(0, 247, 255, 0.5);
            border-radius: 10px;
            cursor: pointer;
            display: block;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .controls button {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 10px 15px;
            cursor: pointer;
            font-family: 'Share Tech Mono', monospace;
        }
        
        .controls button.active {
            background-color: var(--highlight-color);
            color: var(--bg-color);
            border-color: var(--highlight-color);
        }
    </style>
</head>
<body>

    <canvas id="resultCanvas"></canvas>

    <div class="controls">
        <button id="btnsingle" class="active" onclick="startFlow('single')">Single Play (New Record)</button>
        <button id="btnsingle_normal" onclick="startFlow('single_normal')">Single Play (Normal)</button>
        <button id="btnranked" onclick="startFlow('ranked')">Ranked Match (Win)</button>
        <button id="btnfree" onclick="startFlow('free')">Free Match (Lose)</button>
    </div>

    <script>
        const canvas = document.getElementById('resultCanvas');
        const ctx = canvas.getContext('2d');
        const controlButtons = document.querySelectorAll('.controls button');

        const WIDTH = 800;
        const HEIGHT = 600;

        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        // --- State Management ---
        let currentStep = -1;
        let currentMode = 'single';
        let stepStartTime = 0;
        let flowTimeout;
        let animationFrameId;
        
        // --- Configuration ---
        const COLORS = {
            primaryText: '#e0e0e0',
            highlight: '#00f7ff',
            win: '#ffd700',
            lose: '#d94444',
            newRecord: '#ff5733',
            rateUp: '#4caf50',
            rateDown: '#f44336',
            label: '#aaa',
        };

        const scenarios = {
            single: { win: true, newRecord: true, statusText: 'New Record!', flowDelays: [1500, 2000, 2000] },
            single_normal: { win: true, newRecord: false, statusText: '', flowDelays: [0, 2000, 2000] },
            ranked: { win: true, newRecord: false, statusText: 'YOU WIN', flowDelays: [1500, 2500] },
            free: { win: false, newRecord: false, statusText: 'GAME OVER', flowDelays: [1500, 2500] }
        };

        // Easing function for smooth animations
        function easeOutQuad(t) { return t * (2 - t); }
        function easeInQuad(t) { return t * t; }

        // --- Drawing Utilities ---
        function drawText(text, x, y, size, font, color, align = 'center', baseline = 'middle') {
            ctx.font = `${size}px ${font}`;
            ctx.fillStyle = color;
            ctx.textAlign = align;
            ctx.textBaseline = baseline;
            ctx.fillText(text, x, y);
        }

        // --- Drawing Functions for each step ---
        function drawBackground() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
        }
        
        function drawStep1(elapsed) {
            const scenario = scenarios[currentMode];
            const duration = 500; // ms
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutQuad(progress);

            ctx.globalAlpha = easedProgress;
            
            const scale = 0.8 + 0.2 * easedProgress;
            ctx.save();
            ctx.translate(WIDTH / 2, HEIGHT / 2);
            ctx.scale(scale, scale);

            const color = scenario.win ? (scenario.newRecord ? COLORS.newRecord : COLORS.win) : COLORS.lose;
            ctx.shadowColor = color;
            ctx.shadowBlur = 15 + 15 * Math.sin(elapsed / 500); // Pulsing glow
            
            drawText(scenario.statusText, 0, 0, 100, 'Orbitron', color);
            
            ctx.restore();
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = 0;
        }

        function drawSinglePlayDetails(elapsed) {
            const fadeInDuration = 700;
            const progress = Math.min(elapsed / fadeInDuration, 1);
            ctx.globalAlpha = easeOutQuad(progress);

            drawText('TIME', WIDTH / 2, 120, 24, 'Orbitron', COLORS.highlight);
            drawText('06:25', WIDTH / 2, 180, 72, 'Orbitron', COLORS.primaryText);
            drawText('BEST: 06:15', WIDTH / 2, 230, 20, 'Share Tech Mono', COLORS.label);
        }
        
        function drawSinglePlaySupplementary(elapsed) {
             const fadeInDuration = 500;
             const progress = Math.min(elapsed / fadeInDuration, 1);
             ctx.globalAlpha = easeOutQuad(progress);
             
             drawText('RANK: 123 / 1000 (Top 12.3%)', WIDTH / 2, 320, 28, 'Share Tech Mono', COLORS.primaryText);
             
             // Stats Grid
             const stats = [
                 { label: 'WPM', value: '85.4' },
                 { label: 'Blocks', value: '150' },
                 { label: 'Miss', value: '10 (2.5%)' },
             ];
             stats.forEach((stat, i) => {
                 const x = WIDTH / 2 + (i - 1) * 200;
                 drawText(stat.label, x, 400, 22, 'Share Tech Mono', COLORS.label);
                 drawText(stat.value, x, 435, 28, 'Share Tech Mono', COLORS.primaryText);
             });
        }

        function drawMultiplayerSupplementary(elapsed, winnerPlayer, showRates) {
            const fadeInDuration = 500;
            const progress = Math.min(elapsed / fadeInDuration, 1);
            ctx.globalAlpha = easeOutQuad(progress);

            const p1Data = { name: 'Player 1 (Taro)', blocks: 150, wpm: '95.2', miss: '10 (2.1%)', rateBefore: 1500, rateAfter: 1523 };
            const p2Data = { name: 'Player 2 (Jiro)', blocks: 125, wpm: '88.1', miss: '15 (3.4%)', rateBefore: 1610, rateAfter: 1587 };
            
            const players = [p1Data, p2Data];

            players.forEach((p, index) => {
                const x = WIDTH / 4 + 20 + (index * (WIDTH / 2 - 40));
                const y = HEIGHT / 2;
                const isWinner = (winnerPlayer === index + 1);

                ctx.save();
                ctx.translate(x, y);

                if (isWinner) {
                    const scale = 1 + 0.05 * progress;
                    ctx.scale(scale, scale);
                    ctx.strokeStyle = COLORS.win;
                    ctx.shadowColor = COLORS.win;
                    ctx.shadowBlur = 10;
                } else {
                    ctx.strokeStyle = `rgba(0, 247, 255, 0.3)`;
                }
                
                ctx.lineWidth = 2;
                ctx.strokeRect(-160, -140, 320, 280);
                ctx.shadowBlur = 0;

                // Player Name
                drawText(p.name, 0, -110, 24, 'Orbitron', isWinner ? COLORS.win : COLORS.primaryText);

                // Rate Change
                if (showRates) {
                    const rateChange = p.rateAfter - p.rateBefore;
                    const sign = rateChange >= 0 ? '+' : '';
                    const color = rateChange >= 0 ? COLORS.rateUp : COLORS.rateDown;
                    drawText('RATE', 0, -70, 18, 'Share Tech Mono', COLORS.label);
                    drawText(`${p.rateBefore} → ${p.rateAfter} (${sign}${rateChange})`, 0, -45, 22, 'Share Tech Mono', color);
                }

                // Stats
                drawText('WPM', -80, 20, 18, 'Share Tech Mono', COLORS.label, 'center');
                drawText(p.wpm, -80, 50, 24, 'Share Tech Mono', COLORS.primaryText, 'center');
                
                drawText('Blocks', 80, 20, 18, 'Share Tech Mono', COLORS.label, 'center');
                drawText(p.blocks, 80, 50, 24, 'Share Tech Mono', COLORS.primaryText, 'center');

                drawText('Miss', 0, 90, 18, 'Share Tech Mono', COLORS.label);
                drawText(p.miss, 0, 120, 24, 'Share Tech Mono', COLORS.primaryText);
                
                ctx.restore();
            });
        }
        
        function drawActionButtons(elapsed) {
            const fadeInDuration = 500;
            const progress = Math.min(elapsed / fadeInDuration, 1);
            ctx.globalAlpha = easeOutQuad(progress);

            ctx.strokeStyle = COLORS.highlight;
            ctx.lineWidth = 2;
            
            ctx.strokeRect(WIDTH/2 - 220, HEIGHT - 80, 200, 50);
            drawText('もう一度', WIDTH/2 - 120, HEIGHT - 55, 18, 'Orbitron', COLORS.highlight);

            ctx.strokeRect(WIDTH/2 + 20, HEIGHT - 80, 200, 50);
            drawText('メインメニューへ', WIDTH/2 + 120, HEIGHT - 55, 18, 'Orbitron', COLORS.highlight);
        }

        // --- Main Loop ---
        function animate(timestamp) {
            const elapsed = timestamp - stepStartTime;
            drawBackground();

            // Step 1: Status Text (e.g., YOU WIN)
            if (currentStep === 0) {
                if (currentMode !== 'single_normal') { // Skip for normal single play
                    drawStep1(elapsed);
                }
                animationFrameId = requestAnimationFrame(animate);
                return;
            }
            
            // --- Single Player Flow ---
            if (currentMode.startsWith('single')) {
                const isNewRecord = currentMode === 'single';
                const stepOffset = isNewRecord ? 0 : -1; // Adjust step index for normal run

                if (currentStep >= 1 + stepOffset) {
                    const animElapsed = (currentStep === 1 + stepOffset) ? elapsed : Infinity;
                    drawSinglePlayDetails(animElapsed);
                }
                if (currentStep >= 2 + stepOffset) {
                    const animElapsed = (currentStep === 2 + stepOffset) ? elapsed : Infinity;
                    drawSinglePlaySupplementary(animElapsed);
                }
                if (currentStep >= 3 + stepOffset) {
                    const animElapsed = (currentStep === 3 + stepOffset) ? elapsed : Infinity;
                    drawActionButtons(animElapsed);
                }
            }
            // --- Multiplayer Flow ---
            else {
                if (currentStep >= 1) { // Player Cards
                    const animElapsed = (currentStep === 1) ? elapsed : Infinity;
                    const isRanked = currentMode === 'ranked';
                    const winner = scenarios[currentMode].win ? 1 : 2;
                    drawMultiplayerSupplementary(animElapsed, winner, isRanked);
                }
                if (currentStep >= 2) { // Buttons
                    const animElapsed = (currentStep === 2) ? elapsed : Infinity;
                    drawActionButtons(animElapsed);
                }
            }
            
            animationFrameId = requestAnimationFrame(animate);
        }

        // --- Flow Control ---
        function proceedFlow() {
            clearTimeout(flowTimeout);
            currentStep++;
            stepStartTime = performance.now();
            
            const delays = scenarios[currentMode].flowDelays;
            if (currentStep < delays.length) {
                flowTimeout = setTimeout(proceedFlow, delays[currentStep]);
            }
        }
        
        window.startFlow = function(mode) {
            currentMode = mode;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            clearTimeout(flowTimeout);
            
            currentStep = -1;
            proceedFlow();
            
            animationFrameId = requestAnimationFrame(animate);

            controlButtons.forEach(btn => btn.classList.remove('active'));
            const activeButton = document.getElementById(`btn${mode}`);
            if (activeButton) {
                activeButton.classList.add('active');
            }
        }

        canvas.addEventListener('click', proceedFlow);
        
        document.fonts.ready.then(() => {
            startFlow('single');
        });

    </script>
</body>
</html>

