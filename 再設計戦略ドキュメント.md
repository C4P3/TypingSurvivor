# 再設計戦略ドキュメント
このドキュメントは、既存のタイピング探索ゲームをより堅牢で、拡張性が高く、そして何よりもマルチプレイ対応を円滑に進められるアーキテクチャへと刷新するための戦略を定義するものです。

## 1. 設計のコア原則
再設計は、以下の2つの原則を全ての基本とします。

1. 疎結合 (Loose Coupling):
各クラス（機能）は、他のクラスのことを「知りすぎない」ようにします。AがないとBが動かない、といった直接的な依存を減らし、クラスの独立性を高めます。これにより、機能の交換やテストが容易になります。

2. 関心の分離 (Separation of Concerns):
一つのクラスには、一つの役割だけを持たせます。例えば、「プレイヤーの入力」と「プレイヤーの状態管理」と「プレイヤーの見た目」は、それぞれ別のクラスが担当します。これにより、コードの見通しが良くなり、修正が特定箇所に限定されるため安全になります。

## 2. アーキテクチャ全体の変更点
### a. 脱シングルトンとDI（依存性の注入）
- 現状の課題: GameManager.Instanceのようにどこからでもアクセスできるシングルトンは、クラス間の依存関係を不透明にし、テストを困難にします。

- 新戦略: 各クラスが必要とする機能（例：ISoundManager）を宣言し、外部の専門家（DIコンテナ）がその機能を注入（Inject）するDIパターンへ移行します。これにより、クラスは特定の具象クラス（SoundManager）から解放され、「疎結合」が実現します。

- 導入: まずはDIの考え方を理解し、手動での依存注入から試すなど、段階的に導入します。

### b. アプリケーションの階層構造
- 現状の課題: GameManagerがゲームプレイ以外の責務も持ちがちです。

- 新戦略: アプリケーション全体のライフサイクルを管理する永続的なAppManagerと、各シーンに特化したManager（MainMenuManager, GameManagerなど）に役割を分割します。

- AppManager: シーン遷移、サウンド管理、認証情報など、アプリケーション全体で永続するものを管理します。

- GameManager: ゲームプレイ中のルール（酸素、スコア、勝敗判定）のみに専念します。

### c. サーバー権威モデルの徹底
- 現状の課題: 各クライアントが個別に処理を行うと、プレイヤー間で状態のズレが発生します。

- 新戦略: ホスト（サーバー）が全てのゲーム状態の決定権を持ちます。クライアントは「入力」をサーバーに送信するのみ。ブロック破壊やアイテム取得などの重要なロジックは全てサーバーが実行し、結果を全クライアントに同期させます。

## 3. 主要なクラスの再設計案
|機能|旧クラス|新クラス/パターン|責務|
| ------------- |:-------------:|:-------------:| -----:|
|ゲーム管理|GameManager GameManagerMulti|GameManager + GameState + GameModeStrategy (ストラテジーパターン)|GameManagerは進行役、GameStateはデータ保持、Strategyがシングル/マルチのルールを切り替える。|
|プレイヤー|PlayerController|PlayerFacade + PlayerInput + PlayerStateMachine (ステートパターン)|Inputは入力検知、StateMachineが状態管理、Facadeがそれらの窓口となり、NetworkBehaviourを担う。|
|アイテム|ItemManager ItemData (Enum)|ItemRegistry + ItemService + IItemEffect (ストラテジーパターン)|RegistryはDB、Serviceが効果発動、ItemDataは効果ScriptableObjectへの参照を持つ。|
|UI|UIController|画面別Manager (MainMenuManager等) + 自己完結型コンポーネント|単純なUIは自身で完結。複雑な画面遷移やデータ連携はManagerがイベントを購読し、仲介する。|

## 4. フォルダ構造戦略
**「機能別（Feature-based）」**アプローチを採用し、関連するアセットを機能ごとに集約します。
```bash
Assets
└── 📂_Project
    ├── 📂Features
    │   ├── 📂Core (DI, SceneManagement, Sound...)
    │   ├── 📂Game
    │   │   ├── 📂Gameplay             # ✅ ゲーム進行管理
    │   │   │   ├── GameManager.cs
    │   │   │   └── GameState.cs
    │   │   ├── 📂Items                # ✅ アイテム機能
    │   │   │   ├── 📂_Base            # アイテム共通の基盤
    │   │   │   │   └── 📂Scripts
    │   │   │   │       ├── ItemData.cs
    │   │   │   │       └── IItemEffect.cs
    │   │   │   ├── 📂Bomb             # ✅ "爆弾"に関する全アセット
    │   │   │   │   ├── Bomb_Data.asset
    │   │   │   │   ├── Bomb_Icon.png
    │   │   │   │   └── Bomb_Effect.cs
    │   │   │   └── 📂OxygenTank       # ✅ "酸素タンク"に関する全アセット
    │   │   ├── 📂Player
    │   │   └── 📂Level
    │   └── 📂UI
    │       └── 📂Screens
    │           ├── 📂MainMenu
    │           └── 📂InGameHUD
    ├── 📂Scenes
    └── 📂Settings (ItemRegistry.asset など)
```
# 5. 実践フロー：新規アイテム追加手順
この設計により、アイテム追加は既存コードを触らずに完了します。
1. 効果の定義: (必要なら) IItemEffectを実装した効果クラス (RocketEffect.csなど) を作成する。
    - 場所: Features/Game/Items/（アイテム名）/

2. 効果アセット作成: Unityメニューから上記効果クラスの.assetファイルを作成する。

3. アイテムデータ作成: UnityメニューからItemDataの.assetファイルを作成する。
    - 場所: Features/Game/Items/（アイテム名）/

4. インスペクター設定: 作成したItemDataアセットに、名前、アイコン、そして手順2で作成した効果アセットをドラッグ＆ドロップで設定する。

5. DBへ登録: Settings/ItemRegistry.assetのリストに、手順3で作成したItemDataアセットを追加する。